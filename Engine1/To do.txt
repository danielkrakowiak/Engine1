27.02.2014
	- Add unit tests for mesh loading (loading meshes with several triangles and resued vertices, with and without normals, texcoords)
19.03.2014
	- when creating fipImage in Texture2D - FREE_IMAGE_TYPE is set to FIT_BITMAP by default. However, it is not always the appropriate file type for image. Ex.: 16 bit grayscale heighmaps have different file type. Maybe it should depend on special file formats defined in AssetFileFormat such as RAW_16BIT?
28.03.2014
	- Handle errors in AssetManager::loadAssetsFromDisk and AssetManager::loadAssets - threads shoould not be terminated, exceptions should not be thrown, path to assets should be removed from assets - maybe handle by not doing anything?
11.04.2014
	- Write = operator for every class with copy constructor (otherwise default copy constructor will be used)
12.04.2014
	- check if DirectX SDK can be removed and if only Windows 7 SDK is enough
	- check whether all DirectX headers point to the right SDK (by pointing the cursor over an include)\
	- add texture loading to AssetManager
	- add loading to Gpu to asset manager (read about async resource loading before - probably one loading thread is enough)
15.04.2014
	- Add test case for mesh loading where mesh has some faces with texcoord indexes or normals and some without them (should throw exception if not handled correctly) - audi.obj is an example
22.09.2014
	- should loading assets asynchronously be done statically in BasicAsset class or in a separate AssetLoader class? Loading and managing assets seem to be different tasks... 
13.10.2014
	- implement loading RiggedMesh from .obj file
08.11.2014
	- add more methods for manipulation float44 and float43 - ex. getRotation rename to getRotation, get4x3 rename to getRotationTranslation, add setRotationRow1 etc
	- change bone pose format from float44 to float43 - beacuse last column is useless anyway
15.11.2014
	- methods which return references (especially to lists) should retrurn shared pointer rather than reference. 
	- add File class with path, type, data, loadedFlag? use it in all assets classes (Mesh, Texture etc)
	- SkeletonAnimation requires bonesNames to work (mapping of names to bone indexes) - how should these names be passed so that each SkeletonAnimation doesn't store a copy of that list (shared_ptr?)
	- should boneNames have it's own class with methods like getBoneIndex( std::string name ) ? - would it be used anywhere else but loading animations?
21.11.2014
	- does combining two SkeletonPoses really work? Especially in the case where the same bones are manipulated in both poses. How about joining three or more poses?
	- optimizing SkeletonPose in terms of memory usage? What is the size of this object when used for a typical or large animation?
28.12.2014
	- Const methods ( ex. const Mesh & getMesh() const ) should always return const-object or const-reference. Non-const versions of the same methods can be created to allow modification of the object. 
	- add const and non-const version of some methods (getters mostly) to all classes. Use const method in non-const method. Use const_cast<type> to convert types from const to non-const.
16.05.2014
	- Add tests for: RenderTarget2D, RenderTargetDepth2D.
21.06.2015
	- Add support for text rendering in Direct3DRendererCore. Add support for text rendering in Direct3DDeffreredRenderer (for in-game flowing label, debug texts, UI etc)
13.07.2015
	- Go through all "throw std::exception" and make sure that throwing method has parenthesis "()" in the error message.
	- Add tests for SkeletonMeshVertexShader checking if it throws for incorrect bones-per-vertex-values.
11.11.2015
	-  Texture2D::createFromMemory - WARNING: casting away const qualifier on data - need to make sure that FreeImage doesn't modify the input data!
12.11.2015
	- AssetManager: add due time as priority for each asset in AssetManager. Asset's subassets should be loaded with it's owner's priority.
	  When inserting assets to load in the queues they need to be inserted in the order of increasing due time.
	- IMPORTANT: There is one problem: if one thread (loadAssets method) waits for the sub-assets to be loaded, then it's not loading any assets at that time. Maybe there should be more threads, but only the given number of them active? Non-binary mutex or something?
29.04.2016
	- [Texture] Add constructor from exisitng DX texture and render target view (or swap chain?). For access to the backbuffer.
	- [Texture - Refactor] Can I remove initialize methods from Texture2DGeneric? Move that code to constuctors...
	- [Includes Cleanup] Some headers include <d3d11.h> although they only contain references and pointers to DX types. Replace with forward declarations.
	- [Test Texture] I should test whether constructor options like generateMipMaps (ex. for RenderTarget) really work for all the bindings and remove them if they are not supported.

	Problems with texture class:
	- No generic class without template params to be used as method arguments.
	- PixelType has no usage for textures which are only stored on gpu (like render target) - but restricts their usage in methods etc.


	---------------------------------

	IMPORTANT: AssetManager tests (event the first one) make whole test execution to fail for all tests. But only in Release builds. It works fine in Debug. Why?

	---------------------------------

	How to deal with textures which are not loaded, but store file information (when parsing ModelTexture files etc). 
	Should it ba possible to create empty textures? But lock them internally to make any action impossible?
	But probably a more elegant solution can be found. 

	----------------------------------

	There should also be a very generic texture class which has no params (not even pixel type). It could contain getters to read it's type for dynamic casting.
	Could be useful to pass and store textures sometimes.

	---------------------------------

	Manually call constructors in Texture2D class. Inheriting constructors keeps access modifiers the same as in base class.

	Change Visual Studio to 2015. 2013 doesn't support inheriting constructors!

	New texture class is implemented. Create tests. Check whether inheritance really workds properly.

	I can use "delegeting constructors" to avoid having many constructors in the derived class.

	1) Create classes:

	per binding:
	Texture2D_ShaderResource,
	Texture2D_RenderTarget,
	Texture2D_DepthStencil,
	Texture2D_UnorderedAccess,

	Texture2D_RenderTarget_ShaderResource,
	Texture2D_RenderTarget_UnorderedAccess,
	Texture2D_RenderTarget_UnorderedAccess_ShaderResource,
	Texture2D_DepthStencil_ShaderResource,
	Texture2D_UnorderedAccess_ShaderResource

	per usage:
	Texture2D_Immutable
	Texture2D_Default
	Texture2D_Dynamic

	They all virtually derive from Texture2D_Generic. They have only the needed getters (real or virtual?).

	2) Create final classes which have nothing but declaration of inheritance:
	
	Texture2D_Immutable_ShaderResource,
	Texture2D_Immutable_RenderTarget,
	Texture2D_Immutable_DepthStencil,
	Texture2D_Immutable_UnorderedAccess,
	Texture2D_Immutable_RenderTarget_ShaderResource,
	Texture2D_Immutable_RenderTarget_UnorderedAccess,
	Texture2D_Immutable_RenderTarget_UnorderedAccess_ShaderResource,
	Texture2D_Immutable_DepthStencil_ShaderResource,
	Texture2D_Immutable_UnorderedAccess_ShaderResource

	Texture2D_Default_ShaderResource,
	Texture2D_Default_RenderTarget,
	Texture2D_Default_DepthStencil,
	Texture2D_Default_UnorderedAccess,
	Texture2D_Default_RenderTarget_ShaderResource,
	Texture2D_Default_RenderTarget_UnorderedAccess,
	Texture2D_Default_RenderTarget_UnorderedAccess_ShaderResource,
	Texture2D_Default_DepthStencil_ShaderResource,
	Texture2D_Default_UnorderedAccess_ShaderResource

	Texture2D_Dynamic_ShaderResource,
	Texture2D_Dynamic_RenderTarget,
	Texture2D_Dynamic_DepthStencil,
	Texture2D_Dynamic_UnorderedAccess,
	Texture2D_Dynamic_RenderTarget_ShaderResource,
	Texture2D_Dynamic_RenderTarget_UnorderedAccess,
	Texture2D_Dynamic_RenderTarget_UnorderedAccess_ShaderResource,
	Texture2D_Dynamic_DepthStencil_ShaderResource,
	Texture2D_Dynamic_UnorderedAccess_ShaderResource

	Whooooooaaaaa!!!! How to avoid having 500 constructors???????????????????????????????????? - use constructor delegation in derived classes (using Base::Base;)


	Use virtual inheritance to solve the problem with bindings and usage. Create different classes that derive from interface like TTexture2DGeneric.

	

	Fix tests. Add staging texture tests.

	Find a solution for a problem when you need: TTexture2D< ShaderResource >, but can also accept: TTexture2D< ShaderResource_RenderTarget_UnorderedAccess > etc...
 
	Commit.

	!!! Change naming convention: use m_ in class members.

	- use ComPtr wherever possible instead of raw pointers.

Fix one shader warning.

*** IMPORTANT:
It's strange that we set textures in FragmentShader's setParameters method, but we set buffers in RendererCore draw method. It should be unified.
Example: draw(or renamed to render) method should take model instead of mesh and set textures accordingly. Or buffers should be set in VertexShader setParameters method...
Also constant buffer is set in setParameters...
Also only the shader know on which slots it binds resources. So only the shader know ho to bind/unbind them correctly. Doing it from outside is just guessing and won't work for more complex/diverse shaders.
So probably set buffers, textures, uavs from shader class.

**** IMPORTANT 2:
Maybe I should createa Buffer class. Same as Texture2D. Because we need to store quite many resource ptr to directx with each buffer plus C++ vector. Could be good to group them up. 
Could be a template class taking it's element type at template argument. It would also simplify sending data to and from GPU using buffers. When building volume data structures etc.
+ Check bind flags on different resources - ex. vertex buffers (and normals etc) have bind flag - "default", but should rather hvae "immutable". Default means that I expect GPU to modify these buffers.


Sprobowac potworzyc te kombinacje bindigow i zobaczyc czy na pewno wszystkie dzialaja?

------------------------------------------------
Poprawic operator | dla enuma z bindingiemw teksturze.

RenderTarget      Default, BIND_RENDER_TARGET,
RenderTargetSR   Default, BIND_RENDER_TARGET, BIND_SHADER_RES0URCE
DepthTarget       Default, BIND_DEPTH_STENCIL
DepthTargetSR       Default, BIND_DEPTH_STENCIL, BIND_SHADER_RES0URCE
UnorderedAccessTexture   Default, BIND_UNORDERED_ACCESS,
DynamicTexture           Dynamic, CPU_ACCESS_WRITE, BIND_SHADER_RES0URCE
ImmutableTexture         Immutable, BIND_SHADER_RES0URCE
StagingReadTexture       Staging, CPU_ACCESS_READ,
StagingWriteTexture      Staging, CPU_ACCESS_WRITE, 
StagingReadWriteTexture  Staging, CPU_ACCESS_READ | CPU_ACCESS_WRITE, 

Texture2D< Dynamic, ShaderResource, uchar4 >

VertexBuffer             Immutable
VertexBuffer_SR           Immutable
VertexBuffer_UA           Default
VertexBuffer_SR_UA           Default
DynamicVertexBuffer      Dynamic
DynamicVertexBufferSR      Dynamic
DynamicVertexBufferUA      Dynamic
DynamicVertexBufferSR_UA      Dynamic
IndexBuffer              Immutable
DyanamicIndexBuffer      Dynamic
ConstantBuffer           Dynamic, D3D11_BIND_CONSTANT_BUFFER
UnorderedAccessBuffer
+
UnorderedAccessVertexBuffer
UnorderedAccessIndexBuffer

Immutable
Dynamic
Default
Staging
UnorderedAccess

RenderTarget2D
Texture2D

	RenderTargetTexture2D - dziedziczy po okreslonym typie Texture2D - np. RenderTargetTexture2D< T > Texture2D< Dynamic, RenderTarget, T >
	

A moze miec u podstawy template klasy Texture< ... > i Buffer< ... > i reszte klas stworzyc tylko jako dziedziczenie po okreslonych wersjach tego templatu np. StagingTextureRead : public Texture< Staging, Read >

Nazywam "Texture" to co ma SRV. Ale staging tez ma w nazwie "Texture" a nie ma SRV. Znowu bufory co maja miec w nazwie gdy maja "SRV"?
Moze wlasnie dodac SRV do nazwy tych klas?

Dla ktorych typow trzymac dane po stronie CPU? Jak dlugo? A moze wywalac zaraz po wyslaniu do GPU?

--------------------------------------------------
Engine1
Typ tekstury jako template argument? Np float4, float3, uin3? To by wymuszalo automatycznie odpowiednie formaty dla DXa

Not all textures can load to/from GPU. THis methods are not available in base Texture2D class but rather derived classes such as StagingRWTexture2D, StagingRTexture2D, StagingWTexture2D, WTexture2D (or DynamicTexture2D)
Also, not every texture type has shader resource view (staging doesn't)

Not all texture data is aligned. Textures loaded from a file are usually aligned. But textures created by hand usually aren't. There should be alignment(or lineSize) field in texture used when uploading texture to GPU.

How to calculate alignment for other mipmap levels?

Checking bitsPerPixel in loadCpuToGpu has bug. should be "else if", not "if"

Dopisac do floa4, float3, int3 itp operacje += wektora z wektorem.
--------------------------------------------------


Pass vertex, index buffers to the raytracing shader. Raytrace triangle mesh.

Add my own binary format of mesh (block and skeleton). It could also store bounding box info etc. It would load much faster.

Make fieldOfView application member. Pass it (or set through setters) to renderers.

How to deal with calculating/updating bounding box for SkeletonMesh?

Add new renderer class - like ScreenREnderer or FinalFrameRenderer etc. It should have shaders taking many screen-size textures and combine them together and shade pixels.
It should be similar to frame renderer.

Ability to select an actor by clicking on it. Using ray tracing.
Ability to move and rotate actors and lights. Ability to edit light properties by clicking special keys (Ctrl +/-, r,g,b)

Create various models and save them to files.

Add other phases of rendering. Rendering color, normals etc. Then rendering the final image. 

How to do raytracing on the GPU --------------------------

How to pass vertex data to compute shader if I can't have one buffer as vertex buffer and shader resource at the same time.
Could use RawBuffers as suggested here: http://stackoverflow.com/questions/19907062/how-can-i-feed-compute-shader-results-into-vertex-shader-w-o-using-a-vertex-buff
It just requires some casting in compute shader, but works fine.

First shader: For all rays, find the intersection distance, hit actor (or model), hit triangle -> save to texture.
For each actor in the current scene node run second shader (pass model textures etc):
Second shader: For all rays, calculate the received color.

How to pass many meshes to shader at the same time?
* Maybe use one huge buffer for vertex data and each mesh has a view to only a part of this buffer.
And then also one special view to access the whole buffer.
* Or the same huge buffer approach but with each mesh remebering it's start/end index in that buffer.

----------------------------------------------------------

Implementation order:
1) Generating rays from camera (for test) or from depth buffer
2) Outputing rays as pixels, (pos, albedo, spec, roughness etc)
3) Ray-Box test
4) Shading a layer (no shadows)
5) Shadow-rays tests
6) Storing scene (mesh list/ptrs) on GPU
7) Ray-Mesh test


1) for each layer:
- render depth/pos + albedo/normal/spec/roughness (using DX or RT)
- shade - 1 pass for each light - use SM/RT -> color
2) for each layer - from the last one
- blur the reflections, refractions
- combine with the previous layer

Idea:
- when calculatin range of a light source - it's bounding volume doesn't have to be a sphere. The more precise the bounding volume to more calculations we save. Maybe even a few volumes could describe a lights range?

Next 0:

//////////
 - Add some math functions to measure corruption of matrices

 - Add: matrix difference (sum of squared distances), matrix inverse, measure matrix orgonality (multiply inverse by the transpose and return difference to identity matrix)
 - Optionally add: orthogonalization - later on... To fix corrupted matrices and compare visual results

/////////

- option to read os some range of keyframes/time/ticks from animation file
- option to split an animation into a few by keyframe/time/tick etc.

- add move constructor to some classes? (but only the ones which are designed to be returned from methods by object) 
- add move assignment to some classes? (but only to those for which creating another object from an existing one makes sense)

- test combining poses (skeleton-space, parent-space)
- add method to substract poses (leave only the difference between poses)


- add option to ignore bones which are not in mesh when loading an animation file. How to make sure that missing bones are not in between of the existing ones? Useful to apply complex animation to a sipler version of mesh (LOD etc)

- Refactor Font and FontCharacter classes.

- for methods - opening bracket in the next line. Refactor.

- in BlockMesh, SkeletonMesh buffer getters should return reference?

- 3d text rendering

- make RectangleMesh derive from BlockMesh (to be able to render it with BlockMeshShader) ?

- shouldn't shader path be hardcoded in the shader class? Why two instances of BlockMeshShader can have different path? Is that useful and correct?

Next2:

	- zdublowac gettery w SkeletonMesh tab by byly wersje const i non-const. Jak w BlockMesh.


